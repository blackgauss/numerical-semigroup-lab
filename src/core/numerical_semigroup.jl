# Numerical Semigroup Type
# 
# A numerical semigroup is a subset S ⊆ ℕ₀ that is:
# 1. Closed under addition: if a, b ∈ S, then a + b ∈ S
# 2. Contains 0
# 3. Has finite complement in ℕ₀ (finite number of gaps)

"""
    NumericalSemigroup <: AbstractNumericalSet

A numerical semigroup: a subset of ℕ₀ closed under addition with finitely many gaps.

Every numerical semigroup can be generated by a finite set of positive integers.
If the generators are coprime (gcd = 1), the semigroup has finitely many gaps.

# Fields
- `gaps::BitSet`: The gaps (positive integers not in the semigroup)
- `generators::Vector{Int}`: A set of generators for the semigroup
- `frobenius::Int`: The Frobenius number (largest gap), -1 if no gaps
- `genus::Int`: The number of gaps
- `multiplicity::Int`: The smallest positive element (minimum generator)
- `embedding_dimension::Int`: The cardinality of minimal generating set

# Constructors
```julia
NumericalSemigroup(gaps::BitSet, generators::Vector{Int}, ...)  # Direct construction
```

Use `semigroup_from_generators()` and `semigroup_from_gaps()` factory functions
instead of calling constructors directly.

# Examples
```julia
# From generators
S = semigroup_from_generators([3, 5])
S.frobenius  # 7
S.genus      # 4 (gaps: 1, 2, 4, 7)

# From gaps
T = semigroup_from_gaps([1, 2, 4, 7])
generators(T)  # [3, 5]
```
"""
struct NumericalSemigroup <: AbstractNumericalSet
    gaps::BitSet
    generators::Vector{Int}
    frobenius::Int
    genus::Int
    multiplicity::Int
    embedding_dimension::Int
    
    # Inner constructor with validation
    function NumericalSemigroup(gaps::BitSet, generators::Vector{Int}, 
                                frobenius::Int, genus::Int, 
                                multiplicity::Int, embedding_dim::Int)
        # Validation
        if !isempty(generators) && any(g <= 0 for g in generators)
            throw(ArgumentError("All generators must be positive"))
        end
        
        if genus < 0
            throw(ArgumentError("Genus must be non-negative"))
        end
        
        if frobenius < -1
            throw(ArgumentError("Frobenius number must be >= -1"))
        end
        
        if multiplicity < 1 && genus > 0
            throw(ArgumentError("Multiplicity must be positive for non-trivial semigroup"))
        end
        
        new(gaps, generators, frobenius, genus, multiplicity, embedding_dim)
    end
end

# Implement NumericalSet interface
Base.:(==)(S::NumericalSemigroup, T::NumericalSemigroup) = S.gaps == T.gaps

function Base.hash(S::NumericalSemigroup, h::UInt)
    # Hash based on gaps (canonical representation)
    hash(S.gaps, hash(:NumericalSemigroup, h))
end

function Base.show(io::IO, S::NumericalSemigroup)
    if S.genus == 0
        print(io, "⟨1⟩")
    else
        print(io, "⟨", join(S.generators, ", "), "⟩")
    end
end

function Base.show(io::IO, ::MIME"text/plain", S::NumericalSemigroup)
    println(io, "NumericalSemigroup ⟨", join(S.generators, ", "), "⟩")
    println(io, "  Genus: ", S.genus)
    println(io, "  Frobenius number: ", S.frobenius)
    println(io, "  Multiplicity: ", S.multiplicity)
    println(io, "  Embedding dimension: ", S.embedding_dimension)
    if S.genus > 0
        gaps_str = join(collect(S.gaps)[1:min(10, S.genus)], ", ")
        if S.genus > 10
            gaps_str *= ", ..."
        end
        print(io, "  Gaps: [", gaps_str, "]")
    end
end

"""
    generators(S::NumericalSemigroup) -> Vector{Int}

Return the minimal generating set of the semigroup.
"""
generators(S::NumericalSemigroup) = S.generators

"""
    gaps(S::NumericalSemigroup) -> BitSet

Return the gaps of the semigroup.
"""
gaps(S::NumericalSemigroup) = S.gaps

"""
    genus(S::NumericalSemigroup) -> Int

Return the genus (number of gaps) of the semigroup.
"""
genus(S::NumericalSemigroup) = S.genus

"""
    frobenius_number(S::NumericalSemigroup) -> Int

Return the Frobenius number (largest gap) of the semigroup.
Returns -1 if there are no gaps (i.e., 1 is a generator).
"""
frobenius_number(S::NumericalSemigroup) = S.frobenius

"""
    multiplicity(S::NumericalSemigroup) -> Int

Return the multiplicity (smallest positive element) of the semigroup.
"""
multiplicity(S::NumericalSemigroup) = S.multiplicity

"""
    embedding_dimension(S::NumericalSemigroup) -> Int

Return the embedding dimension (cardinality of minimal generating set).
"""
embedding_dimension(S::NumericalSemigroup) = S.embedding_dimension

"""
    Base.in(n::Int, S::NumericalSemigroup) -> Bool

Check if `n` is in the semigroup `S`.

# Examples
```julia
S = NumericalSemigroup([3, 5])
3 in S   # true
4 in S   # false (4 is a gap)
8 in S   # true (8 = 3 + 5)
```
"""
function Base.in(n::Int, S::NumericalSemigroup)
    if n < 0
        return false
    elseif n == 0
        return true
    elseif n > S.frobenius && S.frobenius >= 0
        # Beyond Frobenius number, everything is in the semigroup
        return true
    else
        # Check if n is a gap
        return !(n in S.gaps)
    end
end

"""
    elements_up_to(S::NumericalSemigroup, n::Int) -> Vector{Int}

Return all elements of the semigroup up to and including `n`.

# Examples
```julia
S = NumericalSemigroup([3, 5])
elements_up_to(S, 10)  # [0, 3, 5, 6, 8, 9, 10]
```
"""
function elements_up_to(S::NumericalSemigroup, n::Int)
    if n < 0
        return Int[]
    end
    
    elements = Int[0]  # 0 is always in the semigroup
    
    for i in 1:n
        if i in S
            push!(elements, i)
        end
    end
    
    return elements
end

"""
    minimal_generating_set_from_gaps(gaps::BitSet) -> Vector{Int}

Compute the minimal generating set from a set of gaps.

An element n is a minimal generator if:
1. n is not a gap (i.e., n is in the semigroup)
2. n cannot be written as a sum of two positive elements that are also in the semigroup

# Algorithm
Iterate through positive integers, checking if each non-gap can be expressed 
as a sum of two smaller non-gaps. The search continues until we find m 
consecutive non-gaps that are all expressible (where m is the multiplicity),
since beyond that point all elements are expressible.
"""
function minimal_generating_set_from_gaps(gaps::BitSet)
    if isempty(gaps)
        # No gaps means ⟨1⟩
        return [1]
    end
    
    frobenius = maximum(gaps)
    
    # Find multiplicity (smallest positive non-gap)
    m = 1
    while m in gaps
        m += 1
    end
    
    minimal_gens = Int[]
    
    # Upper bound: once we have m consecutive expressible elements,
    # all further elements are also expressible.
    # Safe bound: frobenius + m (all generators must be < conductor + m)
    upper_bound = frobenius + m
    
    for n in 1:upper_bound
        if n in gaps
            continue  # n is a gap, can't be a generator
        end
        
        # Check if n can be expressed as sum of two positive non-gaps
        # n = a + b where a, b > 0 and neither is a gap
        can_express = false
        for a in 1:(n ÷ 2)  # Only check up to n/2 to avoid duplicates
            if !(a in gaps)
                b = n - a
                if b > 0 && !(b in gaps)
                    # n = a + b where both a and b are in the semigroup
                    can_express = true
                    break
                end
            end
        end
        
        if !can_express
            # n is a minimal generator
            push!(minimal_gens, n)
        end
    end
    
    return minimal_gens
end
