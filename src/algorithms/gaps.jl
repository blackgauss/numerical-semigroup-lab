# Algorithms for computing gaps from generators

"""
    compute_gaps_from_generators(generators::Vector{Int}) -> Vector{Int}

Compute all gaps of the numerical semigroup generated by `generators`.

Uses dynamic programming to determine which positive integers can be represented
as non-negative integer linear combinations of the generators.

# Arguments
- `generators::Vector{Int}`: Positive integers that generate the semigroup (need not be coprime)

# Returns
- `Vector{Int}`: Sorted vector of gaps (positive integers not in the semigroup)

# Examples
```julia
# Two-generator semigroup <3, 5>
gaps = compute_gaps_from_generators([3, 5])
# Returns [1, 2, 4, 7]

# Three generators
gaps = compute_gaps_from_generators([5, 7, 11])
```

# Algorithm
Uses a sieve approach: mark all representable numbers up to an upper bound,
then collect unmarked numbers as gaps. The Frobenius number (if it exists)
is the largest gap.

# Complexity
- Time: O(F · k) where F is the Frobenius number and k is the number of generators
- Space: O(F)
"""
function compute_gaps_from_generators(generators::Vector{Int})
    # Validate input
    if isempty(generators)
        throw(ArgumentError("Generator set cannot be empty"))
    end
    
    if any(g <= 0 for g in generators)
        throw(ArgumentError("All generators must be positive"))
    end
    
    # Remove duplicates and sort
    gens = sort(unique(generators))
    
    # Special case: if 1 is a generator, there are no gaps
    if gens[1] == 1
        return Int[]
    end
    
    # Check if generators are coprime (gcd = 1)
    g = reduce(gcd, gens)
    if g > 1
        throw(ArgumentError("Generators must be coprime (gcd must be 1), got gcd=$g"))
    end
    
    # Use specialized algorithm for 2 generators
    if length(gens) == 2
        return compute_gaps_two_generators(gens[1], gens[2])
    end
    
    # General case: use dynamic programming sieve
    return compute_gaps_general(gens)
end

"""
    compute_gaps_two_generators(a::Int, b::Int) -> Vector{Int}

Specialized algorithm for two coprime generators.

Uses the formula: Frobenius number = ab - a - b
Genus = (a-1)(b-1)/2

This is much faster than the general algorithm.

# Examples
```julia
gaps = compute_gaps_two_generators(3, 5)  # [1, 2, 4, 7]
gaps = compute_gaps_two_generators(7, 11) # Frobenius = 7*11 - 7 - 11 = 59
```
"""
function compute_gaps_two_generators(a::Int, b::Int)
    @assert gcd(a, b) == 1 "Generators must be coprime"
    
    # Frobenius number for two coprime generators
    frobenius = a * b - a - b
    
    if frobenius < 0
        return Int[]
    end
    
    # Use sieve to find gaps
    can_represent = falses(frobenius + 1)
    can_represent[1] = true  # 0 is always in the semigroup
    
    # Mark all numbers that can be represented
    for n in 0:frobenius
        if can_represent[n + 1]
            # From n, we can reach n+a and n+b
            if n + a <= frobenius
                can_represent[n + a + 1] = true
            end
            if n + b <= frobenius
                can_represent[n + b + 1] = true
            end
        end
    end
    
    # Also mark direct multiples
    for i in 1:frobenius÷a
        can_represent[i*a + 1] = true
    end
    for j in 1:frobenius÷b
        can_represent[j*b + 1] = true
    end
    
    # Collect gaps (indices where can_represent is false, excluding 0)
    gaps = Int[]
    for n in 1:frobenius
        if !can_represent[n + 1]
            push!(gaps, n)
        end
    end
    
    return gaps
end

"""
    compute_gaps_general(generators::Vector{Int}) -> Vector{Int}

General algorithm for n generators using dynamic programming.

Computes an upper bound for the Frobenius number and uses a sieve
to mark all representable numbers.

# Algorithm
The Frobenius number is bounded by the largest generator squared
(this is a loose but safe bound for the general case).
"""
function compute_gaps_general(generators::Vector{Int})
    gens = sort(unique(generators))
    
    if gens[1] == 1
        return Int[]
    end
    
    # Upper bound for Frobenius number (conservative estimate)
    # For general case, use largest generator squared
    # (Tighter bounds exist but require more analysis)
    max_gen = gens[end]
    upper_bound = max_gen * max_gen
    
    # For small generator sets, we can use a tighter bound
    if length(gens) == 3
        # Better bound for 3 generators
        upper_bound = min(upper_bound, gens[1] * gens[2])
    end
    
    # Mark representable numbers using DP
    can_represent = falses(upper_bound + 1)
    can_represent[1] = true  # 0 is in the semigroup
    
    # Dynamic programming: build up representable numbers
    for n in 0:upper_bound
        if can_represent[n + 1]
            for g in gens
                if n + g <= upper_bound
                    can_represent[n + g + 1] = true
                end
            end
        end
    end
    
    # Find the actual Frobenius number (largest gap)
    frobenius = -1
    for n in upper_bound:-1:1
        if !can_represent[n + 1]
            frobenius = n
            break
        end
    end
    
    if frobenius == -1
        # No gaps found
        return Int[]
    end
    
    # Collect all gaps up to Frobenius number
    gaps = Int[]
    for n in 1:frobenius
        if !can_represent[n + 1]
            push!(gaps, n)
        end
    end
    
    return gaps
end
