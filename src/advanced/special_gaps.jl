# Special Gaps and Frobenius Children
#
# This module implements functions for identifying special gaps
# and computing Frobenius children (descendants with specific Frobenius numbers).

"""
    special_gaps(S::NumericalSemigroup) -> Vector{Int}

Compute the special gaps (pseudo-Frobenius numbers) of a numerical semigroup.

A gap g is special (or a pseudo-Frobenius number) if g + s ∈ S for all s ∈ S \\ {0}.
Equivalently, g is maximal in the gap poset under the Kunz ordering.

For symmetric semigroups, the only special gap is F itself (type = 1).

This is an alias for `void(S)`.

# Examples
```julia
S = NumericalSemigroup([3, 5])
special_gaps(S)  # [7] - the Frobenius number for symmetric semigroup
```
"""
special_gaps(S::NumericalSemigroup) = void(S)

"""
    is_symmetric(S::NumericalSemigroup) -> Bool

Check if S is a symmetric semigroup.

A semigroup is symmetric if for every integer x with 0 ≤ x ≤ F,
exactly one of x and F - x is in S. Equivalently, for every gap g,
F - g is in S (not a gap).

All numerical semigroups generated by two coprime integers are symmetric.

# Examples
```julia
S = NumericalSemigroup([3, 5])
is_symmetric(S)  # true - all 2-generated semigroups are symmetric

T = NumericalSemigroup([3, 5, 7])
is_symmetric(T)  # Check symmetry
```
"""
function is_symmetric(S::NumericalSemigroup)
    S.frobenius < 0 && return true  # ℕ₀ is trivially symmetric
    
    F = S.frobenius
    for g in S.gaps
        complement = F - g
        # For symmetric: if g is a gap, then F - g must be in S (not a gap)
        if complement >= 0 && complement in S.gaps
            return false
        end
    end
    
    return true
end

"""
    is_pseudo_symmetric(S::NumericalSemigroup) -> Bool

Check if S is a pseudo-symmetric semigroup.

A semigroup is pseudo-symmetric if type(S) = 2 and the two pseudo-Frobenius
numbers satisfy a certain relationship.

# Examples
```julia
S = NumericalSemigroup([4, 5, 6])
is_pseudo_symmetric(S)
```
"""
function is_pseudo_symmetric(S::NumericalSemigroup)
    pf = void(S)
    length(pf) != 2 && return false
    
    F = S.frobenius
    # For pseudo-symmetric: F should be even and F/2 should be a pseudo-Frobenius
    F % 2 != 0 && return false
    
    return (F ÷ 2) in pf
end

"""
    add_specialgap(S::NumericalSemigroup, g::Int) -> NumericalSemigroup

Add a gap to the semigroup (creating a child in the tree).

The gap must be a valid element to remove (greater than Frobenius number
and removable without breaking closure).

# Examples
```julia
S = NumericalSemigroup([3, 5])
T = add_specialgap(S, 8)  # Add 8 as a new gap
```
"""
function add_specialgap(S::NumericalSemigroup, g::Int)
    # Validate that g can be added as a gap
    if g <= S.frobenius
        throw(ArgumentError("New gap must be greater than Frobenius number $(S.frobenius)"))
    end
    
    if g ∉ S
        throw(ArgumentError("$g is already a gap"))
    end
    
    if !can_be_new_frobenius(S, g)
        throw(ArgumentError("$g cannot be added as a gap (would break semigroup closure)"))
    end
    
    new_gaps = vcat(collect(S.gaps), g)
    return semigroup_from_gaps(new_gaps)
end

"""
    get_frobchildren(S::NumericalSemigroup) -> Vector{NumericalSemigroup}

Get children of S whose Frobenius number is exactly F(S) + 1.

These are the "Frobenius children" — semigroups obtained by adding F(S) + 1
as a new gap.

# Examples
```julia
S = NumericalSemigroup([3, 5])
fc = get_frobchildren(S)  # Children with Frobenius = 8
```
"""
function get_frobchildren(S::NumericalSemigroup)
    F = S.frobenius
    F < 0 && return NumericalSemigroup[]
    
    new_gap = F + 1
    
    if new_gap in S && can_be_new_frobenius(S, new_gap)
        return [add_specialgap(S, new_gap)]
    end
    
    return NumericalSemigroup[]
end

"""
    left_primitive(S::NumericalSemigroup) -> Bool

Check if S is left primitive.

A semigroup is left primitive if removing the largest minimal generator
results in a semigroup with the same Frobenius number.
"""
function left_primitive(S::NumericalSemigroup)
    isempty(S.generators) && return false
    length(S.generators) == 1 && return false
    
    max_gen = maximum(S.generators)
    
    try
        T = remove_minimal_generator(S, max_gen)
        return T.frobenius == S.frobenius
    catch
        return false
    end
end

"""
    right_primitive(S::NumericalSemigroup) -> Bool

Check if S is right primitive.

A semigroup is right primitive if the multiplicity is a minimal generator
of index 1 in the Apéry set.
"""
function right_primitive(S::NumericalSemigroup)
    S.genus == 0 && return true
    
    ap = apery_set(S)
    m = S.multiplicity
    
    # Check if 1 appears exactly once in Apéry weights
    weights = [w ÷ m for w in ap]
    return count(w -> w == 1, weights) >= m - 1
end

"""
    almost_symmetric_gaps(S::NumericalSemigroup) -> Vector{Int}

Find gaps g such that adding the Frobenius number to the semigroup
(i.e., considering the parent) makes g become special.

These are gaps that are "almost" special in the current semigroup.
"""
function almost_symmetric_gaps(S::NumericalSemigroup)
    S.frobenius < 0 && return Int[]
    
    F = S.frobenius
    almost = Int[]
    
    for g in S.gaps
        # g is almost symmetric if F - g = F (i.e., g = 0) is impossible
        # or if F - g would be in the parent
        if g != F  # Exclude Frobenius itself
            complement = F - g
            # Check if complement is in S (not a gap)
            if complement >= 0 && complement ∉ S.gaps
                push!(almost, g)
            end
        end
    end
    
    return sort(almost)
end

"""
    fundamental_gaps(S::NumericalSemigroup) -> Vector{Int}

Compute the fundamental gaps of the semigroup.

A gap g is fundamental if g ∉ G + G, where G is the set of gaps.
Fundamental gaps are exactly the gaps that appear in the minimal presentation.

# Examples
```julia
S = NumericalSemigroup([5, 7, 9])
fundamental_gaps(S)
```
"""
function fundamental_gaps(S::NumericalSemigroup)
    gap_list = collect(S.gaps)
    isempty(gap_list) && return Int[]
    
    # G + G: sums of two gaps
    gap_sums = Set{Int}()
    for g1 in gap_list
        for g2 in gap_list
            push!(gap_sums, g1 + g2)
        end
    end
    
    # Fundamental = gaps not in G + G
    return sort([g for g in gap_list if g ∉ gap_sums])
end

"""
    forced_gaps(S::NumericalSemigroup, g::Int) -> Vector{Int}

Given a gap g, find all gaps that are "forced" by g.

A gap h is forced by g if h can be written as g + s for some s ∈ S.
"""
function forced_gaps(S::NumericalSemigroup, g::Int)
    g ∉ S.gaps && throw(ArgumentError("$g is not a gap of S"))
    
    forced = Int[]
    F = S.frobenius
    
    for s in elements_up_to(S, F - g)
        h = g + s
        if h > g && h in S.gaps
            push!(forced, h)
        end
    end
    
    return sort(forced)
end
