# Numerical Semigroups

This guide covers working with numerical semigroups in NumericalSemigroupLab.jl.

## Overview

A **numerical semigroup** $S$ is a subset of $\mathbb{N}_0$ that is:
1. Closed under addition: $a, b \in S \Rightarrow a + b \in S$
2. Contains zero: $0 \in S$
3. Has finite complement (finitely many gaps)

Every numerical semigroup is uniquely determined by its **minimal generating set** — the smallest set of positive integers that generates it under addition.

## Creating Numerical Semigroups

### From Generators

The most common way to create a numerical semigroup:

```julia
using NumericalSemigroupLab

# Create ⟨3, 5⟩ - the semigroup generated by 3 and 5
S = NumericalSemigroup([3, 5])

# Explicit factory function
S = semigroup_from_generators([3, 5])

# Multiple generators
T = NumericalSemigroup([5, 7, 11])
```

!!! note "Coprimality"
    For a numerical semigroup to have finitely many gaps, the generators must be coprime (their GCD must be 1).

### From Gaps

If you know the gap set:

```julia
# Create from gaps
S = semigroup_from_gaps([1, 2, 4, 7])
generators(S)  # [3, 5]
```

The package automatically computes the minimal generating set.

## Fundamental Invariants

Every numerical semigroup has several important invariants:

```julia
S = NumericalSemigroup([3, 5])

# Genus: number of gaps
genus(S)  # 4

# Frobenius number: largest gap
frobenius_number(S)  # 7

# Multiplicity: smallest positive element
multiplicity(S)  # 3

# Embedding dimension: number of minimal generators
embedding_dimension(S)  # 2

# Get the gaps
gaps(S)  # BitSet([1, 2, 4, 7])

# Get the generators
generators(S)  # [3, 5]
```

## Membership Testing

Check if an integer belongs to a semigroup:

```julia
S = NumericalSemigroup([3, 5])

# Using 'in' syntax
3 in S   # true (generator)
4 in S   # false (gap)
8 in S   # true (8 = 3 + 5)
0 in S   # true (always)
-1 in S  # false (negative)
```

The membership test is efficient:
- For elements ≤ Frobenius number: O(1) gap lookup
- For elements > Frobenius number: always in the semigroup

## Generating Elements

Get elements of the semigroup:

```julia
S = NumericalSemigroup([3, 5])

# All elements up to 20
elements_up_to(S, 20)
# [0, 3, 5, 6, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]

# Small elements (less than Frobenius number)
small_elements(S)  # [0, 3, 5, 6]
```

## Apéry Sets

The **Apéry set** of $S$ with respect to $n \in S$ is:

$$\text{Ap}(S, n) = \{s \in S : s - n \notin S\}$$

It contains exactly one element from each residue class modulo $n$:

```julia
S = NumericalSemigroup([3, 5])

# Apéry set with respect to 3
apery_set(S, 3)  # [0, 5, 10]
# 0 ≡ 0 (mod 3), 5 ≡ 2 (mod 3), 10 ≡ 1 (mod 3)

# Apéry set with respect to multiplicity (default)
apery_set(S)  # Same as apery_set(S, 3)
```

The Apéry set encodes much of the semigroup's structure.

## Minimal Generators

Not every element that generates the semigroup is a *minimal* generator:

```julia
S = NumericalSemigroup([3, 5])

# Check individual elements
is_minimal_generator(S, 3)  # true
is_minimal_generator(S, 5)  # true
is_minimal_generator(S, 6)  # false (6 = 3 + 3)
is_minimal_generator(S, 8)  # false (8 = 3 + 5)

# Get the minimal generating set
minimal_generating_set(S)  # [3, 5]
```

An element is a minimal generator if it cannot be expressed as a sum of smaller positive elements of the semigroup.

## Two-Generator Semigroups

When a semigroup is generated by two coprime integers $a$ and $b$, there are elegant closed formulas:

```julia
a, b = 7, 11
S = NumericalSemigroup([a, b])

# Frobenius number: F(a,b) = ab - a - b
frobenius_number(S)  # 59 = 7*11 - 7 - 11

# Genus: g(a,b) = (a-1)(b-1)/2
genus(S)  # 30 = (7-1)*(11-1)/2
```

The package uses an optimized algorithm for two-generator semigroups.

## Connection to Numerical Sets

Every numerical semigroup is also a numerical set, so all `NumericalSet` functions work:

```julia
S = NumericalSemigroup([3, 5])

# Partition correspondence
p = partition(S)

# Atom monoid gaps
atom_gaps = atom_monoid_gaps(S)
```

This is because `NumericalSemigroup <: AbstractNumericalSet`.

## Comparing Semigroups

Two semigroups are equal if they have the same gaps:

```julia
S1 = semigroup_from_generators([3, 5])
S2 = semigroup_from_gaps([1, 2, 4, 7])

S1 == S2  # true
```

## Displaying Semigroups

```julia
S = NumericalSemigroup([3, 5])

println(S)  # ⟨3, 5⟩

# Detailed display
display(S)
# NumericalSemigroup ⟨3, 5⟩
#   Genus: 4
#   Frobenius number: 7
#   Multiplicity: 3
#   Embedding dimension: 2
#   Gaps: [1, 2, 4, 7]
```

## Performance Tips

### Caching

Apéry set computations are cached:

```julia
S = NumericalSemigroup([11, 13])

# First call: computed
@time apery_set(S, 11)  # ~0.001s

# Second call: cached
@time apery_set(S, 11)  # ~0.00001s
```

### Use Factory Functions

When constructing many semigroups, the explicit factory functions are clearer:

```julia
# For generators
S = semigroup_from_generators([3, 5, 7])

# For gaps
T = semigroup_from_gaps([1, 2, 4])
```

## Common Patterns

### Exploring a Family of Semigroups

```julia
# All 2-generator semigroups with multiplicity ≤ 10
for m in 2:10
    for n in (m+1):20
        if gcd(m, n) == 1
            S = NumericalSemigroup([m, n])
            println("⟨$m, $n⟩: genus=$(genus(S)), F=$(frobenius_number(S))")
        end
    end
end
```

### Finding Semigroups by Property

```julia
# Find semigroups with genus 5
candidates = [[3, 11], [4, 7], [5, 6], [3, 8], [4, 9]]
for gens in candidates
    S = NumericalSemigroup(gens)
    if genus(S) == 5
        println("$gens has genus 5")
    end
end
```

## See Also

- [Mathematical Background](../math-background.md) - Theory of numerical semigroups
- [Numerical Semigroup API](../api/numerical-semigroups.md) - Complete function reference
- [Numerical Sets](numerical-sets.md) - Related numerical set operations
