# Getting Started

This guide will help you get up and running with NumericalSemigroupLab.jl.

## Installation

### From GitHub

```julia
using Pkg
Pkg.add(url="https://github.com/blackgauss/numerical-semigroup-lab")
```

### From Source

If you want to contribute or modify the package:

```bash
git clone https://github.com/blackgauss/numerical-semigroup-lab.git
cd numerical-semigroup-lab
```

Then in Julia:

```julia
using Pkg
Pkg.activate(".")
Pkg.instantiate()
```

## First Steps

### Working with Numerical Sets

A numerical set is defined by its **gaps** (the positive integers not in the set).

```julia
using NumericalSemigroupLab

# Create a numerical set with gaps {1, 2, 4, 5, 7}
ns = NumericalSet([1, 2, 4, 5, 7])

# The set contains: {0, 3, 6, 8, 9, 10, 11, ...}
# (all non-negative integers except the gaps)
```

#### Key Properties

```julia
# Frobenius number: largest gap
frobenius_number(ns)  # Returns 7

# Multiplicity: smallest positive element in the set
multiplicity(ns)      # Returns 3

# Elements smaller than the Frobenius number
small_elements(ns)    # Returns [0, 3, 6]
```

### Working with Partitions

A partition is a non-increasing sequence of positive integers.

```julia
# Create a partition
p = Partition([5, 4, 3, 1])

# The parts are automatically sorted
p.parts  # [5, 4, 3, 1]
```

#### Partition Operations

```julia
# Conjugate (transpose of Ferrers diagram)
conj = conjugate(p)
conj.parts  # [4, 3, 3, 2, 1]

# Hook lengths for each cell
hooks = hook_lengths(p)
# Returns a matrix:
# [[8, 6, 5, 3, 1],
#  [6, 4, 3, 1],
#  [4, 2, 1],
#  [1]]
```

### The Correspondence

Convert between numerical sets and partitions:

```julia
# From numerical set to partition
ns = NumericalSet([1, 2, 4, 5, 7])
p_parts = partition(ns)  # [3, 3, 2, 2, 1, 1]

# From partition to gaps
p = Partition([5, 4, 3, 1])
gaps_vec = gaps(p)  # [1, 2, 4, 5, 8]
```

### Working with Numerical Semigroups

A numerical semigroup is generated by a set of positive integers.

```julia
# Create from generators
S = NumericalSemigroup([3, 5])

# Or use explicit factory functions
S = semigroup_from_generators([3, 5])
T = semigroup_from_gaps([1, 2, 4, 7])
```

#### Key Properties

```julia
S = NumericalSemigroup([3, 5])

# Fundamental invariants
genus(S)              # 4 (number of gaps)
frobenius_number(S)   # 7 (largest gap)
multiplicity(S)       # 3 (smallest positive element)
embedding_dimension(S) # 2 (number of minimal generators)

# Get generators and gaps
generators(S)         # [3, 5]
gaps(S)               # BitSet([1, 2, 4, 7])
```

#### Membership and Elements

```julia
# Check membership
3 in S    # true
4 in S    # false (4 is a gap)
8 in S    # true (8 = 3 + 5)

# Get elements up to a value
elements_up_to(S, 15)  # [0, 3, 5, 6, 8, 9, 10, 11, 12, 13, 14, 15]
```

#### Apéry Sets

The Apéry set captures the structure of residue classes:

```julia
# Apéry set with respect to 3
apery_set(S, 3)  # [0, 5, 10]

# Apéry set with respect to multiplicity (default)
apery_set(S)     # [0, 5, 10]
```

#### Minimal Generators

```julia
# Check if an element is a minimal generator
is_minimal_generator(S, 3)  # true
is_minimal_generator(S, 6)  # false (6 = 3 + 3)

# Get the minimal generating set
minimal_generating_set(S)   # [3, 5]
```

## Common Patterns

### Creating Objects

```julia
# Numerical sets from gap lists
ns1 = NumericalSet([1, 2, 3])
ns2 = NumericalSet([2, 3, 4, 6, 7, 8])

# Partitions from part sequences
p1 = Partition([5, 3, 2])      # Sorted: [5, 3, 2]
p2 = Partition([1, 5, 3, 2])   # Auto-sorted: [5, 3, 2, 1]
```

### Exploring Properties

```julia
# For numerical sets
ns = NumericalSet([1, 2, 4, 5])
println("Frobenius: ", frobenius_number(ns))
println("Multiplicity: ", multiplicity(ns))
println("Small elements: ", small_elements(ns))

# For partitions
p = Partition([4, 3, 1])
println("Conjugate: ", conjugate(p).parts)
println("Is semigroup: ", is_semigroup(p))
```

### Computing Invariants

```julia
# Atom monoid of a numerical set
ns = NumericalSet([1, 3, 5])
atom_gaps = atom_monoid_gaps(ns)

# Atom partition
p = Partition([5, 4, 3, 1])
atom_p = atom_partition(p)
```

## Performance Tips

### Use Caching

The package automatically caches expensive computations:

```julia
p = Partition([20, 19, 18, 17, 16])

# First call: computed from scratch (~30 μs)
hooks1 = hook_lengths(p)

# Second call: retrieved from cache (~10 μs)
hooks2 = hook_lengths(p)
```

### Clear Caches When Needed

```julia
# Check cache sizes
cache_stats()

# Clear all caches to free memory
clear_all_caches!()
```

### Batch Operations

Process multiple objects efficiently:

```julia
# Process many partitions
partitions = [Partition([i, i-1, i-2]) for i in 5:20]
conjugates = [conjugate(p) for p in partitions]
```

## Common Pitfalls

### Empty Gaps

```julia
# A set with no gaps is all of ℕ₀
ns = NumericalSet(Int[])  # gaps = {}
frobenius_number(ns)      # Returns -1 (convention)
```

### Invalid Input

```julia
# These will throw errors:
Partition([0, 1, 2])     # ❌ Parts must be positive
Partition([-1, 3, 5])    # ❌ Parts must be positive
NumericalSet([-1, 2, 3]) # ❌ Gaps must be non-negative
```

### Order Matters (or doesn't!)

```julia
# Partitions are auto-sorted
p1 = Partition([3, 5, 2])
p1.parts  # [5, 3, 2]

# Gaps can be in any order
ns1 = NumericalSet([5, 2, 1, 4])  # Same as NumericalSet([1, 2, 4, 5])
```

## Next Steps

- Learn about the [Mathematical Background](math-background.md) behind these structures
- Explore [Partition operations](guide/partitions.md) in detail
- Understand [Numerical Sets](guide/numerical-sets.md) more deeply
- Try the [Examples](examples/basic.md) to see real applications

## Quick Reference Card

| Task | Code | Result |
|------|------|--------|
| Create numerical set | `NumericalSet([1,2,4])` | Set with gaps 1,2,4 |
| Create partition | `Partition([5,3,1])` | Partition (5,3,1) |
| Create semigroup | `NumericalSemigroup([3,5])` | Semigroup ⟨3,5⟩ |
| Get Frobenius number | `frobenius_number(ns)` | Largest gap |
| Get multiplicity | `multiplicity(ns)` | Smallest positive non-gap |
| Get genus | `genus(S)` | Number of gaps |
| Conjugate partition | `conjugate(p)` | Transposed partition |
| Hook lengths | `hook_lengths(p)` | Hook length matrix |
| Convert to partition | `partition(ns)` | Partition from numerical set |
| Get gaps from partition | `gaps(p)` | Gaps vector |
| Check membership | `n in S` | Is n in semigroup? |
| Get elements | `elements_up_to(S, n)` | All elements ≤ n |
| Apéry set | `apery_set(S, n)` | Apéry set mod n |
| Generators | `generators(S)` | Minimal generating set |
