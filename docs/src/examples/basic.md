# Basic Usage Examples

This page demonstrates common use cases and workflows with NumericalSemigroupLab.jl.

## Example 1: Exploring a Numerical Semigroup

Let's explore the numerical semigroup generated by {3, 5}:

```julia
using NumericalSemigroupLab

# First, compute the gaps manually for <3, 5>
function gaps_two_generator(a, b)
    @assert gcd(a, b) == 1 "Generators must be coprime"
    
    frobenius = a * b - a - b
    gaps = Int[]
    
    for n in 1:frobenius
        # Check if n = ia + jb for some i,j ≥ 0
        can_make = false
        for i in 0:n÷a
            if (n - i*a) % b == 0
                can_make = true
                break
            end
        end
        if !can_make
            push!(gaps, n)
        end
    end
    
    return gaps
end

# Create the numerical set
gaps = gaps_two_generator(3, 5)
println("Gaps: ", gaps)  # [1, 2, 4, 7]

ns = NumericalSet(gaps)

# Explore properties
println("Frobenius number: ", frobenius_number(ns))  # 7
println("Multiplicity: ", multiplicity(ns))          # 3
println("Genus: ", length(gaps))                     # 4
println("Small elements: ", small_elements(ns))      # [0, 3, 5, 6]
```

**Output:**
```
Gaps: [1, 2, 4, 7]
Frobenius number: 7
Multiplicity: 3
Genus: 4
Small elements: [0, 3, 5, 6]
```

## Example 2: The Partition Correspondence

Convert between numerical sets and partitions:

```julia
# Start with a numerical set
ns = NumericalSet([1, 2, 4, 5, 7])

# Convert to partition
p_parts = partition(ns)
println("Partition: ", p_parts)  # [3, 3, 2, 2, 1, 1]

# Create Partition object and explore
p = Partition(p_parts)

# Visualize as Ferrers diagram
function show_ferrers(p::Partition)
    for part in p.parts
        println("■"^part)
    end
end

println("\nFerrers diagram:")
show_ferrers(p)

# Compute conjugate
conj = conjugate(p)
println("\nConjugate: ", conj.parts)  # [4, 3, 3, 2, 1]

println("\nConjugate diagram:")
show_ferrers(conj)

# Verify round-trip
gaps_back = gaps(p)
println("\nGaps from partition: ", sort(gaps_back))
println("Original gaps: ", sort(collect(gaps(ns))))
println("Match: ", gaps_back == sort(collect(gaps(ns))))
```

## Example 3: Hook Lengths and Young Tableaux

Count the number of standard Young tableaux using hook lengths:

```julia
function count_standard_young_tableaux(p::Partition)
    n = sum(p.parts)
    hooks = hook_lengths(p)
    
    # Flatten hook length matrix
    all_hooks = vcat(hooks...)
    
    # Hook length formula: f^λ = n! / ∏h(i,j)
    hook_product = prod(all_hooks)
    
    return factorial(n) ÷ hook_product
end

# Test with several partitions
test_partitions = [
    [3, 2, 1],      # 16 SYT
    [4, 3, 2, 1],   # 768 SYT
    [5, 4, 3],      # 896 SYT
]

for parts in test_partitions
    p = Partition(parts)
    count = count_standard_young_tableaux(p)
    println("Partition $parts has $count standard Young tableaux")
end
```

**Output:**
```
Partition [3, 2, 1] has 16 standard Young tableaux
Partition [4, 3, 2, 1] has 768 standard Young tableaux
Partition [5, 4, 3] has 896 standard Young tableaux
```

## Example 4: Finding Self-Conjugate Partitions

Find partitions that equal their own conjugate:

```julia
function find_self_conjugate_partitions(max_size::Int)
    self_conjugates = []
    
    # Generate partitions up to size n
    for n in 1:max_size
        # Try all partitions of n
        # (simplified - just checking some patterns)
        for k in 1:n
            parts = Int[]
            remaining = n
            current = k
            
            while remaining > 0 && current > 0
                push!(parts, current)
                remaining -= current
                current -= 1
            end
            
            if sum(parts) == n
                p = Partition(parts)
                conj = conjugate(p)
                
                if p.parts == conj.parts
                    push!(self_conjugates, parts)
                end
            end
        end
    end
    
    return unique(self_conjugates)
end

# Find self-conjugate partitions up to size 10
self_conj = find_self_conjugate_partitions(10)
println("Self-conjugate partitions:")
for parts in self_conj
    println("  ", parts)
end
```

## Example 5: Analyzing Genus Sequences

Study how Frobenius numbers relate to genus:

```julia
function analyze_genus_patterns(max_genus::Int)
    results = Dict{Int, Vector{Tuple{Vector{Int}, Int}}}()
    
    # Generate various gap patterns
    for g in 1:max_genus
        results[g] = []
        
        # Example patterns for genus g
        # Pattern 1: consecutive gaps from 1
        gaps1 = collect(1:g)
        ns1 = NumericalSet(gaps1)
        push!(results[g], (gaps1, frobenius_number(ns1)))
        
        # Pattern 2: every other number
        if g >= 2
            gaps2 = [2i-1 for i in 1:g]
            ns2 = NumericalSet(gaps2)
            push!(results[g], (gaps2, frobenius_number(ns2)))
        end
    end
    
    return results
end

# Analyze patterns
patterns = analyze_genus_patterns(5)

for genus in 1:5
    println("\nGenus $genus:")
    for (gaps, frob) in patterns[genus]
        println("  Gaps $gaps → Frobenius = $frob")
    end
end
```

## Example 6: Batch Processing

Process multiple numerical sets efficiently:

```julia
# Generate test cases
test_cases = [
    [1, 2, 3],
    [1, 2, 4, 5],
    [1, 3, 5, 7, 9],
    [2, 3, 4, 6, 7, 8],
    [1, 2, 4, 5, 7, 8, 10],
]

# Process all at once
function analyze_batch(gap_lists)
    results = map(gap_lists) do gaps
        ns = NumericalSet(gaps)
        p_parts = partition(ns)
        p = Partition(p_parts)
        
        (
            gaps = gaps,
            frobenius = frobenius_number(ns),
            genus = length(gaps),
            multiplicity = multiplicity(ns),
            partition = p_parts,
            conjugate = conjugate(p).parts,
        )
    end
    return results
end

# Time the batch processing
@time results = analyze_batch(test_cases)

# Display results
println("\nBatch Analysis Results:")
println("="^70)
for r in results
    println("Gaps: ", r.gaps)
    println("  Frobenius: ", r.frobenius, ", Genus: ", r.genus, 
            ", Multiplicity: ", r.multiplicity)
    println("  Partition: ", r.partition)
    println("  Conjugate: ", r.conjugate)
    println()
end
```

## Example 7: Verifying Mathematical Properties

Test theoretical properties:

```julia
# Property 1: conjugate is an involution
function test_conjugate_involution(test_count=100)
    all_passed = true
    for i in 1:test_count
        # Generate random partition
        parts = sort([rand(1:10) for _ in 1:rand(1:5)], rev=true)
        p = Partition(parts)
        
        # Apply conjugate twice
        conj = conjugate(p)
        conj_conj = conjugate(conj)
        
        # Should get back original
        if p.parts != conj_conj.parts
            println("FAIL: $parts")
            all_passed = false
        end
    end
    
    return all_passed
end

# Property 2: hook length formula properties
function test_hook_properties(p::Partition)
    hooks = hook_lengths(p)
    
    # All hooks should be positive
    all_positive = all(all(h > 0 for h in row) for row in hooks)
    
    # Corner hook should be 1
    corner_is_one = (hooks[end][end] == 1)
    
    # Top-left hook should be largest
    n = sum(p.parts)
    top_left = hooks[1][1]
    
    return all_positive && corner_is_one
end

# Run tests
println("Testing conjugate involution...")
if test_conjugate_involution()
    println("✓ All tests passed!")
else
    println("✗ Some tests failed")
end

println("\nTesting hook properties...")
test_partitions = [[5,4,3,1], [10,8,6,4,2], [7,7,5,3]]
for parts in test_partitions
    p = Partition(parts)
    if test_hook_properties(p)
        println("✓ Partition $parts: hooks valid")
    else
        println("✗ Partition $parts: hooks invalid")
    end
end
```

## Example 8: Performance Comparison

Compare cached vs uncached performance:

```julia
# Create a large partition
p = Partition([20, 19, 18, 17, 16, 15, 14, 13, 12, 11])

# Clear caches
clear_all_caches!()

# First computation (uncached)
println("First hook_lengths call (uncached):")
@time hooks1 = hook_lengths(p)

# Second computation (cached)
println("\nSecond hook_lengths call (cached):")
@time hooks2 = hook_lengths(p)

# Verify same result
println("\nResults identical: ", hooks1 === hooks2)

# Show cache statistics
println("\nCache stats:")
println(cache_stats())

# Clear and repeat for conjugate
clear_all_caches!()

println("\n\nFirst conjugate call (uncached):")
@time conj1 = conjugate(p)

println("\nSecond conjugate call (cached):")
@time conj2 = conjugate(p)

println("\nResults identical: ", conj1 === conj2)
```

## Tips for Your Own Explorations

1. **Start Small**: Test with small examples first to understand behavior
2. **Use Visualization**: Ferrers diagrams help build intuition
3. **Verify Properties**: Always verify mathematical properties hold
4. **Profile Performance**: Use `@time` to understand computational costs
5. **Clear Caches**: Use `clear_all_caches!()` when benchmarking
6. **Check Round-Trips**: Verify bijections work correctly

## Next Steps

- Try [Advanced Examples](advanced.md) for more complex applications
- Read the [API Reference](../api/types.md) for complete function documentation
- Explore the [Mathematical Background](../math-background.md) for theory
